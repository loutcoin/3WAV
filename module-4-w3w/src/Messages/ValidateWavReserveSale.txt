Placing this here because as of current the WavReserve is not intended to publically "sell" items in the same manner as the WavStore,
therefore gathering c/sPriceUsdVal data, doing price conversions, and transferring ETH to _creatorId, potential collaborators, and the service is
not applicable as in other scenarios.
So I'm placing these functions here for temporary access, but they will very likely not be needed as I have different plans for WavReserve.

/**
     * @notice Validates price property, converts to wei, and debits supply.
     * @dev Authenticates Content Token WavReserve supply and pricing data prior to sale.
     *      Function Selector: 0x7b994452
     * @param _hashId Identifier of Content Token being queried.
     * @param _numToken Content Token identifier used to specify the token index being queried.
     * @param _quantity Value being deducted from relevant remaining supply source.
     */
    function _validateDebitWavReserve(
        bytes32 _hashId,
        uint16 _numToken,
        uint112 _quantity
    ) internal returns (uint256) {
        // _cPriceUsd = <x> encoded value found in sContentToken mapping
        uint32 _cPriceUsd = ReturnMapping.returnSContentTokenPriceUsdVal(
            _hashId
        );

        // if <x> value is found and exists...
        if (_cPriceUsd != 0 && _numToken == 0) {
            // Decode <x> encoded value
            uint32 _cPriceUsdVal = PriceDBC._cPriceUsdValDecoder(_cPriceUsd);
            cDebitWavReserve(_hashId, _quantity);
            return WavFeed.usdToWei(uint256(_cPriceUsdVal));
        }

        _cPriceUsd = ReturnMapping.returnCContentTokenCPriceUsdVal(_hashId);

        if (_cPriceUsd != 0 && _numToken == 0) {
            uint32 _cPriceUsdVal = PriceDBC._cPriceUsdValDecoder(_cPriceUsd);
            cDebitWavReserve(_hashId, _quantity);
            return WavFeed.usdToWei(uint256(_cPriceUsdVal));
        }

        // If returned sPriceUsdVal of hashId != 0...
        uint112 _sPriceUsdVal = ReturnMapping.returnCContentTokenSPriceUsdVal(
            _hashId
        );

        if (_sPriceUsdVal != 0 && _numToken != 0) {
            //if(!tokenEnabledState(_hashId, _numToken)) ***tokenEnabledState currently deprecated
            //revert WavDBC__BitValIssue();
            // resolve tier and compute price from state map
            uint256 _priceMap = ReturnMapping.returnCContentTokenPriceMap(
                _hashId
            );
            uint8 _priceState = BinaryDBC._decode2BitState(
                _priceMap,
                _numToken
            );
            uint256 _usdPrice = PriceDBC._sPriceUsdValState(
                _priceState,
                _sPriceUsdVal,
                _hashId
            );

            // debit tier pre-release supply
            uint8 _tierId = BinaryDBC._getTier(_hashId, _numToken);
            sDebitWavReserve(_hashId, _tierId, _quantity);

            return WavFeed.usdToWei(_usdPrice);
        }

        revert WavDBC__InputError404();
    }

    /**
     * @notice Validates dynamic quantity of price properties, converts to wei, and debits supply.
     * @dev Authenticates Content Token WavReserve supply and pricing data batch prior to sale.
     *      Function Selector: 0xb2ebf7f4
     * @param _hashIdBatch Batch of Content Token identifier values being queried.
     * @param _numTokenBatch Batch of Content Token identifiers used to specify the token index being queried.
     * @param _quantityBatch Total instances of each numToken.
     */
    function _validateDebitWavReserveBatch(
        bytes32[] calldata _hashIdBatch,
        uint16[] calldata _numTokenBatch,
        uint112[] calldata _quantityBatch
    ) internal returns (uint256[] memory _weiPrice) {
        uint256 _hashLength = _hashIdBatch.length;
        if (
            _hashLength == 0 ||
            _hashLength != _numTokenBatch.length ||
            _hashLength != _quantityBatch.length
        ) {
            revert WavDBC__LengthValIssue();
        }

        _weiPrice = new uint256[](_hashLength);

        for (uint256 i = 0; i < _hashLength; ) {
            bytes32 _hashId = _hashIdBatch[i];
            uint16 _numToken = _numTokenBatch[i];
            uint256 _quantity = _quantityBatch[i];

            // Branch 1: SContentToken priceUsdVal
            uint32 _cPriceUsd = ReturnMapping.returnSContentTokenPriceUsdVal(
                _hashId
            );
            if (_cPriceUsd != 0 && _numToken == 0) {
                uint32 _cPriceUsdVal = PriceDBC._cPriceUsdValDecoder(
                    _cPriceUsd
                );
                cDebitWavReserve(_hashId, _quantity);
                _weiPrice[i] = WavFeed.usdToWei(uint256(_cPriceUsdVal));
                unchecked {
                    ++i;
                }
                continue;
            }

            // Branch 2: CContentToken cPriceUsdVal
            _cPriceUsd = ReturnMapping.returnCContentTokenCPriceUsdVal(_hashId);
            if (_cPriceUsd == 0 && _numToken == 0) {
                uint32 _cPriceUsdVal = PriceDBC._cPriceUsdValDecoder(
                    _cPriceUsd
                );
                cDebitWavReserve(_hashId, _quantity);
                _weiPrice[i] = WavFeed.usdToWei(uint256(_cPriceUsdVal));
                unchecked {
                    ++i;
                }
                continue;
            }

            // Branch 3: CContentToken sPriceUsdVal
            uint112 _sPriceUsdVal = ReturnMapping
                .returnCContentTokenSPriceUsdVal(_hashId);
            if (_sPriceUsdVal != 0 && _numToken != 0) {
                uint256 _priceMap = ReturnMapping.returnCContentTokenPriceMap(
                    _hashId
                );
                uint8 _priceState = BinaryDBC._decode2BitState(
                    _priceMap,
                    _numToken
                );
                uint256 _usdPrice = PriceDBC._sPriceUsdValState(
                    _priceMap,
                    _sPriceUsdVal,
                    _hashId
                );

                uint8 _tierId = BinaryDBC._getTier(_hashId, _numToken);
                sDebitWavReserve(_hashId, _tierId, _quantity);

                _weiPrice[i] = WavFeed.usdToWei(_usdPrice);
                unchecked {
                    ++i;
                }
                continue;
            }
            revert WavDBC__InputError404();
        }
    }