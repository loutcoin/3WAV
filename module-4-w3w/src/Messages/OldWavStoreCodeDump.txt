/** ***** MAKE SURE THIS ENSURES PRERELEASE IS CURRENTLY ACTIVE (preReleaseValidation)
     * @notice Allows manual intervention to pause or resume an active preRelease sale.
     * @dev The input state is '0' by default. An input state of '1' indicates a paused sale state.
     * @param _hashId Identifier of Content Token being queried.
     * @param _inputState Value affecting sale state of Content Token.
     */
    function preReleaseState(bytes32 _hashId, uint8 _inputState) external {
        ReturnValidation.returnIsAuthorized();

        if (_inputState > 1) revert WavStore__InputInvalid();

        // cContentToken branch
        uint96 _releaseVal = ReturnMapping.returnCContentTokenReleaseVal(
            _hashId
        );
        if (_releaseVal != 0) {
            (
                uint96 _startRelease,
                uint96 _endRelease,
                uint96 _preRelease,
                uint8 _pausedAt
            ) = EncoderDecoder._cReleaseValDecoder6(_releaseVal);

            // Only allow pause if preSale is currently active, only allow resume if preSale is paused
            if (
                (_inputState == 1 && _pausedAt != 0) ||
                (_inputState == 0 && _pausedAt != 1)
            ) revert WavStore__InputStateInEffect();
            // Activate _pausedAt state and encode
            uint96 _updatedReleaseVal = EncoderDecoder._cReleaseValEncoder6(
                _startRelease,
                _endRelease,
                _preRelease,
                _inputState
            );

            // Write into cContentToken storage
            CContentTokenStorage.CContentToken
                storage CContentTokenStruct = CContentTokenStorage
                    .cContentTokenStructStorage();
            CContentTokenStruct.cReleaseVal = _updatedReleaseVal;

            emit PreReleaseState(_hashId, _inputState);
            return;
        }
        // sContentToken branch
        // sContentToken branch
        _releaseVal = ReturnMapping.returnSContentTokenReleaseVal(_hashId);

        if (_releaseVal != 0) {
            // Decode
            (
                uint96 _startRelease,
                uint96 _endRelease,
                uint96 _preRelease,
                uint8 _pausedAt
            ) = EncoderDecoder._cReleaseValDecoder6(_releaseVal);

            // Only allow pause if preSale is currently active, only allow resume if preSale is paused
            if (
                (_inputState == 1 && _pausedAt != 0) ||
                (_inputState == 0 && _pausedAt != 1)
            ) revert WavStore__InputStateInEffect();

            // Activate _pausedAt state and encode
            uint96 _updatedReleaseVal = EncoderDecoder._cReleaseValEncoder6(
                _startRelease,
                _endRelease,
                _preRelease,
                _inputState
            );

            SContentTokenStorage.SContentToken
                storage SContentTokenStruct = SContentTokenStorage
                    .sContentTokenStructStorage();
            SContentTokenStruct.releaseVal = _updatedReleaseVal;

            emit PreReleaseState(_hashId, _inputState);
            return;
        }
        // Content Token not found in either storage location
        revert WavStore__InputError404();
    }

    /**
     * @notice Allows manual intervention to pause or resume a plurality of active preRelease sales
     * @dev The input state is '0' by default. An input state of '1' indicates a paused sale state.
     * @param _hashIdBatch Batch of Content Token identifier values being queried.
     * @param _inputStateBatch Batch of values affecting PreRelease sale states of Content Tokens.
     */
    function preReleaseStateBatch(
        bytes32[] calldata _hashIdBatch,
        uint8[] calldata _inputStateBatch
    ) external {
        ReturnValidation.returnIsAuthorized();

        uint256 _hashLength = _hashIdBatch.length;
        if (_hashLength == 0 || _inputStateBatch.length != _hashLength)
            revert WavStore__LengthMismatch();

        // Validate input states
        for (uint256 i = 0; i < _hashLength; ) {
            if (_inputStateBatch[i] > 1) revert WavStore__InputInvalid();
            unchecked {
                ++i;
            }
        }
        // Batch releaseVal data validation
        (
            uint96[] memory _startReleaseBatch,
            uint96[] memory _endReleaseBatch,
            uint96[] memory _preReleaseBatch,
            uint8[] memory _pausedAtBatch
        ) = WavDBC.validateContentTokenReleaseDataBatch(_hashIdBatch);

        // Build updated _pausedAt batch
        uint8[] memory _updatedPausedAtBatch = new uint8[](_hashLength);
        for (uint i = 0; i < _hashLength; ) {
            uint8 _pausedAt = _pausedAtBatch[i];
            uint8 _inputState = _inputStateBatch[i];

            // Only allow pause if preSale is currently active, only allow resume if preSale is paused
            if (
                (_inputState == 1 && _pausedAt != 0) ||
                (_inputState == 0 && _pausedAt != 1)
            ) {
                revert WavStore__InputStateInEffect();
            }
            _updatedPausedAtBatch[i] = _inputState;
            unchecked {
                ++i;
            }
        }
        // Encode releaseVal data in batch
        uint96[] memory _updatedReleaseValBatch = WavDBC
            .cReleaseValEncoderBatch6(
                _startReleaseBatch,
                _endReleaseBatch,
                _preReleaseBatch,
                _updatedPausedAtBatch
            );
        // Write back into correct branch by checking storage presence
        for (uint256 i = 0; i < _hashLength; ) {
            bytes32 _hashId = _hashIdBatch[i];
            uint96 _updatedReleaseVal = _updatedReleaseValBatch[i];

            uint96 _returnData = ReturnMapping.returnCContentTokenReleaseVal(
                _hashId
            );
            if (_returnData != 0) {
                // Write into cContentToken storage
                CContentTokenStorage.CContentToken
                    storage CContentTokenStruct = CContentTokenStorage
                        .cContentTokenStructStorage();
                CContentTokenStruct.cReleaseVal = _updatedReleaseVal;
                unchecked {
                    ++i;
                }
                continue;
            }
            // make sure can just reuse _returnData
            _returnData = ReturnMapping.returnSContentTokenReleaseVal(_hashId);
            if (_returnData != 0) {
                SContentTokenStorage.SContentToken
                    storage SContentTokenStruct = SContentTokenStorage
                        .sContentTokenStructStorage();
                SContentTokenStruct.releaseVal = _updatedReleaseVal;
                unchecked {
                    ++i;
                }
                continue;
            }
            // Should not happen because validateContentTokenReleaseDataBatch should revert
            // In place just as simple extra defensive check
            revert WavStore__InputError404();
        }
        // Emit single batch event
        emit PreReleaseStateBatch(_hashIdBatch, _inputStateBatch);
    }

    /**
     * @notice Allows definition of an _endRelease date for a Content Token post-publication.
     * @dev Mandatory minimum of 72-hour window before _endRelease may be executed.
     * @param _hashId Identifier of Content Token being queried.
     * @param _disablePeriod Quantity of hours until _endRelease takes effect.
     */
    function postManualEndRelease(
        bytes32 _hashId,
        uint96 _disablePeriod
    ) external {
        ReturnValidation.returnIsAuthorized();

        // Minimum enforced _endRelease execution window (72 hours)
        if (_disablePeriod < 72) revert WavStore__InputInvalid();

        // load current hour stamp once
        uint96 _hourStamp = ReturnValidation._currentHourStamp();

        // cContentToken Branch
        uint96 _releaseVal = ReturnMapping.returnCContentTokenReleaseVal(
            _hashId
        );

        if (_releaseVal != 0) {
            (
                uint96 _startRelease,
                uint96 _endRelease,
                uint96 _preRelease,
                uint8 _pausedAt
            ) = EncoderDecoder._cReleaseValDecoder6(_releaseVal);

            // Only allow scheduling if _endRelease undefined
            if (_endRelease != 0) revert WavStore__Immutable();

            // Compute _updatedEndRelease
            uint96 _updatedEndRelease = _hourStamp + _disablePeriod;

            // Create, validate, encode _updatedReleaseVal
            uint96 _updatedReleaseVal = EncoderDecoder._cReleaseValEncoder6(
                _startRelease,
                _updatedEndRelease,
                _preRelease,
                _pausedAt
            );

            // Write into cContentToken storage
            CContentTokenStorage.CContentToken
                storage CContentTokenStruct = CContentTokenStorage
                    .cContentTokenStructStorage();
            CContentTokenStruct.cReleaseVal = _updatedReleaseVal;

            emit PostManualEndRelease(_hashId, _updatedEndRelease);
            return;
        }
        // sContentToken branch
        _releaseVal = ReturnMapping.returnSContentTokenReleaseVal(_hashId);

        if (_releaseVal != 0) {
            // decode
            (
                uint96 _startRelease,
                uint96 _endRelease,
                uint96 _preRelease,
                uint8 _pausedAt
            ) = EncoderDecoder._cReleaseValDecoder6(_releaseVal);

            // Only allow scheduling if _endRelease undefined
            if (_endRelease != 0) revert WavStore__Immutable();

            // Compute _updatedEndRelease
            uint96 _updatedEndRelease = _hourStamp + _disablePeriod;

            // Create, validate, encode _updatedReleaseVal
            uint96 _updatedReleaseVal = EncoderDecoder._cReleaseValEncoder6(
                _startRelease,
                _updatedEndRelease,
                _preRelease,
                _pausedAt
            );
            SContentTokenStorage.SContentToken
                storage SContentTokenStruct = SContentTokenStorage
                    .sContentTokenStructStorage();
            SContentTokenStruct.releaseVal = _updatedReleaseVal;

            emit PostManualEndRelease(_hashId, _updatedEndRelease);
            return;
        }
        // Content Token not found in either storage location
        revert WavStore__InputError404();
    }

    /**
     * @notice Allows definition of _endRelease date for a batch of Content Tokens post-publication.
     * @dev Mandatory minimum of 72-hour window before _endRelease may be executed.
     * @param _hashIdBatch Batch of Content Token identifier values being queried.
     * @param _disablePeriodBatch Quantity of hours until _endRelease takes effect for each hash.
     */
    function postManualEndReleaseBatch(
        bytes32[] calldata _hashIdBatch,
        uint96[] calldata _disablePeriodBatch
    ) external {
        ReturnValidation.returnIsAuthorized();

        uint256 _hashLength = _hashIdBatch.length;
        if (_hashLength < 2 || _disablePeriodBatch.length != _hashLength)
            revert WavStore__LengthMismatch();

        for (uint256 i = 0; i < _hashLength; ) {
            if (_disablePeriodBatch[i] < 72) revert WavStore__InputInvalid();
            unchecked {
                ++i;
            }
        }

        // Load hourStamp
        uint96 _hourStamp = ReturnValidation._currentHourStamp();

        for (uint256 i = 0; i < _hashLength; ) {
            bytes32 _hashId = _hashIdBatch[i];
            uint96 _disablePeriod = _disablePeriodBatch[i];

            // cContentToken Branch
            uint96 _releaseVal = ReturnMapping.returnCContentTokenReleaseVal(
                _hashId
            );
            if (_releaseVal != 0) {
                (
                    uint96 _startRelease,
                    uint96 _endRelease,
                    uint96 _preRelease,
                    uint8 _pausedAt
                ) = EncoderDecoder._cReleaseValDecoder6(_releaseVal);

                // Only allow scheduling if _endRelease undefined
                if (_endRelease != 0) revert WavStore__Immutable();

                // Compute _updatedEndRelease
                uint96 _updatedEndRelease = _hourStamp + _disablePeriod;

                // Create, validate, encode _updatedReleaseVal
                uint96 _updatedReleaseVal = EncoderDecoder._cReleaseValEncoder6(
                    _startRelease,
                    _updatedEndRelease,
                    _preRelease,
                    _pausedAt
                );

                // Write into cContentToken storage
                CContentTokenStorage.CContentToken
                    storage CContentTokenStruct = CContentTokenStorage
                        .cContentTokenStructStorage();
                CContentTokenStruct.cReleaseVal = _updatedReleaseVal;
                unchecked {
                    ++i;
                }
                continue;
            }

            _releaseVal = ReturnMapping.returnSContentTokenReleaseVal(_hashId);
            if (_releaseVal != 0) {
                // decode
                (
                    uint96 _startRelease,
                    uint96 _endRelease,
                    uint96 _preRelease,
                    uint8 _pausedAt
                ) = EncoderDecoder._cReleaseValDecoder6(_releaseVal);

                // Only allow scheduling if _endRelease undefined
                if (_endRelease != 0) revert WavStore__Immutable();

                // Compute _updatedEndRelease
                uint96 _updatedEndRelease = _hourStamp + _disablePeriod;

                // Create, validate, encode _updatedReleaseVal
                uint96 _updatedReleaseVal = EncoderDecoder._cReleaseValEncoder6(
                    _startRelease,
                    _updatedEndRelease,
                    _preRelease,
                    _pausedAt
                );
                SContentTokenStorage.SContentToken
                    storage SContentTokenStruct = SContentTokenStorage
                        .sContentTokenStructStorage();
                SContentTokenStruct.releaseVal = _updatedReleaseVal;

                unchecked {
                    ++i;
                }
                continue;
            }
        }
    }